//-------------------------------------------------------------------
//  Nano RPC
//  https://github.com/tdv/nanorpc
//  Created:     05.2018
//  Copyright (C) 2018 tdv
//-------------------------------------------------------------------

// THIS
#include "session.h"
#include "utility.h"

namespace nanorpc::http::detail
{

session::session(boost::asio::ip::tcp::socket socket, executor_data const &data)
    : data_{data}
    , socket_{std::move(socket)}
    , strand_{socket_.get_executor()}
{
}

void session::run() noexcept
{
    utility::post(socket_.get_executor().context(), [self = shared_from_this()] { self->read(); } );
}

void session::read()
{
    request_ = {};

    boost::beast::http::async_read(socket_, buffer_, request_,
            boost::asio::bind_executor(strand_,
                    std::bind(&session::on_read, shared_from_this(), std::placeholders::_1)
                )
        );
}

void session::on_read(boost::system::error_code const &ec) noexcept
{
    try
    {
        if (ec == boost::asio::error::operation_aborted)
            return;

        if (ec == boost::beast::http::error::end_of_stream)
        {
            close();
            return;
        }

        auto const keep_alive = request_.keep_alive();

        handle_request(std::move(request_));

        if (keep_alive && socket_.is_open())
            read();

        if (!keep_alive && socket_.is_open())
            close();
    }
    catch (std::exception const &e)
    {
        // TODO:
        std::cerr << "Failed to handle request. Error: " << e.what() << std::endl;
    }
}

void session::close()
{
    boost::system::error_code ec;
    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
    if (ec)
    {
        // TODO:
        std::cerr << "Failed to close socket. Message: " << ec.message() << std::endl;
    }
}

void session::handle_request(request_type req)
{
    auto const target = req.target().to_string();

    auto reply = [] (auto resp)
    {
        auto response = std::make_shared<response_type>(std::move(resp));
        boost::beast::http::async_write(socket_, *response,
                boost::asio::bind_executor(strand_,
                        std::bind(&session::on_write, shared_from_this(), std::placeholders::_1, response)
                    )
            );
    }

    auto const not_found = [&req](boost::beast::string_view target)
        {
            response_type res{boost::beast::http::status::not_found, req.version()};
            res.set(boost::beast::http::field::server, BOOST_BEAST_VERSION_STRING);
            res.set(boost::beast::http::field::content_type, "text/html");
            res.keep_alive(req.keep_alive());
            res.body() = "The resource '" + target.to_string() + "' was not found.";
            res.prepare_payload();
            return res;
        };

    auto const iter = data_.executors_.find(target);
    if (iter == end(data_.executors_))
    {
        // TODO: not found
        std::cerr << "Not found. " << target << std::endl;
    }
    else
    {
        auto &executor = iter->second;
        if (!executor)
        {
            // TODO:
            std::cerr << "Error: empty exicutor." << std::endl;
        }
        else
        {
            auto const &content = req.body();
            if (content.empty())
            {
                // TODO:
                std::cerr << "Error: no content." << std::endl;
            }
            else
            {
                try
                {
                    executor({begin(content), end(content)});
                }
                catch (std::exception const &e)
                {
                    // TODO:
                    std::cerr << "Error: " << e.what() << std::endl;
                }
            }
        }
    }

    auto const &content = req.body();
    if (content.empty())
    {
        // TODO:
        std::cerr << "Error: no content." << std::endl;
    }
    else
    {
        try
        {
            //executors_({begin(content), end(content)});
        }
        catch (std::exception const &e)
        {
            // TODO:
            std::cerr << "Error: " << e.what() << std::endl;
        }
    }

    // boost::beast::http::status::ok
    auto response = std::make_shared<response_type>();
    response->keep_alive(req.keep_alive());
    response->set(boost::beast::http::field::server, BOOST_BEAST_VERSION_STRING);
    response->set(boost::beast::http::field::content_type, "text/html");
    response->set(boost::beast::http::field::keep_alive, req.keep_alive() ? "keep-alive" : "closed");
    {
        //std::string content = "Test string.\n";
        std::string content = "Test string.\n";
        response->body() = content;
        response->content_length(content.length());
    }
    response->prepare_payload();

    boost::beast::http::async_write(socket_, *response,
            boost::asio::bind_executor(strand_,
                    std::bind(&session::on_write, shared_from_this(), std::placeholders::_1, response)
                )
        );
}

void session::on_write(boost::system::error_code const &, std::shared_ptr<response_type>)
{
    //close();
}

}   // namespace nanorpc::http::detail
